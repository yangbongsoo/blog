# 스레드 안전성
스레드에 안전한 코드를 작성하는 것은 근본적으로는 상태, 특히 공유되고 변경할 수 있는 상태에 대한 접근을 관리하는 것이다.

공유됐다는 것은 여러 스레드가 특정 변수에 접근할 수 있다는 뜻이고, 변경할 수 있다(mutable)는 것은 해당 변수 값이 변경될 수 있다는 뜻이다. **스레드 안전성이 마치 코드를 보호하는 것처럼 이해하는 경우가 많지만, 실제로는 데이터에 제어 없이 동시 접근하는 걸 막으려는 의미임을 알아두자.**

자바에서 동기화를 위한 기본 수단은 synchronized 키워드로서 배타적인 락을 통해 보호 기능을 제공한다. 하지만 volatile 변수, 명시적 락, 단일 연산 변수(atomic variable)를 사용하는 경우에도 '동기화'라는 용어를 사용한다.

### 스레드 안전성이란?
스레드 안전하지 않은 클래스와 안전한 클래스는 어떻게 구분할까? 또 '안전하다'는 것은 무든 뜻일까? 스레드에 대한 납득할 만한 정의의 핵심은 모두 정확성(correctness) 개념과 관계 있다. 스레드 안전성에 대한 정의가 모호한 것은 정확성에 대한 명확한 정의가 없기 때문이다.

정확성이란 클래스가 해당 클래스의 명세에 부합한다는 뜻이다. 잘 작성된 클래스 명세는 객체 상태를 제약하는 불변조건(invariants)과 연산 수행 후 효과를 기술하는 후조건(postcondition)을 정의한다. 하지만 종종 클래스에 대한 명세를 충분히 작성하지 않는 상황에서 과연 작성한 코드가 클래스 명세에 부합하는지 알 수 있을까? 물론 알 수 없다. 하지만 일단 "특정 코드가 동작한다"고 확신하기만 하면 어쨌든 명세를 활용하지 못할 것도 없다. 이런 '코드 신뢰도'는 많은 사람이 생각하는 정확성과 대략 일치한다. 이런 맥락에서 단일 스레드에서의 정확성은 '척 보면 아는' 어떤 것이라고 가정하자. 낙관적으로 '정확성'을 인지할 수 있는 어떤 것으로 정의하면 스레드 안전성도 다소 덜 순환적으로  정의할 수 있다. 즉 여러 스레드가 클래스에 접근할 때 계속 정확하게 동작하면 해당 클래스는 스레드 안전하다.

예제 : 상태 없는 서블릿
``` java
@ThreadSafe
public class StatelessFactorizer implements Servlet {
    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        encodeIntoResponse(resp, factors);
    }
}
```
위 코드는 간단한 인수분해 서블릿이다. 인수분해할 숫자를 서블릿 요청에서 빼내 인수분해하고, 결과를 서블릿 응답에 인코딩해 넣는다. StatelessFactorizer는 대부분의 서블릿처럼 상태가 없다. 즉 선언한 변수가 없고 다른 클래스의 변수를 참조하지도 않는다. 특정 계산을 위한 일시적인 상태는 스레드의 스택에 저장되는 지역 변수에만 저장하고, 실행하는 해당 스레드에서만 접근할 수 있다. 따라서 StatelessFactorizer에 접근하는 특정 스레드는 같은 StatelessFactorizer에 접근하는 다른 스레드의 결과에 영향을 줄 수 없다. 두 스레드가 상태를 공유하지 않기 때문에 사실상 서로 다른 인스턴스에 접근하는 것과 같다. 상태 없는 객체에 접근하는 스레드가 어떤 일을 하든 다른 스레드가 수행하는 동작의 정확성에 영향을 끼칠 수 없기 때문에 **상태 없는 객체는 항상 스레드 안전하다.**

많은 서블릿을 상태 없이 구현할 수 있다는 점은 서블릿을 스레드 안전하게 만드는 부담을 줄여준다. 서블릿이 여러 요청 간에 뭔가를 기억할 필요가 있을 때에야 스레드 안전성이 문제가 된다.

### 단일 연산

### 락
### 활동성과 성능
# 객체 공유

# 객체 구성

# 구성 단위