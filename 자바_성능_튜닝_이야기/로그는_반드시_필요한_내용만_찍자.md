## Story10 로그는 반드시 필요한 내용만 찍자

### System.out.println()의 문제점
대부분의 개발자들은 로그를 찍기 위해서 System.out.println() 메서드를 사용한 시스템 로그를 많이 사용한다.
가장 편하고, 확인하기 좋은 방법이지만 성능에 영향을 많이 주는 경우가 빈번히 발생한다.

왜 성능에 영향을 많이 줄까? 파일이나 콘솔에 로그를 남길 경우를 생각해 보자. 내용이 완전히
프린트되거나 저장될 때까지, 뒤에 프린트하려는 부분은 대기 할 수밖에 없다. 특히 콘솔에 로그를
남길 경우에는 더더욱 그렇다. 그렇게 되면 애플리케이션에서는 대기 시간이 발생한다. 이 대기 시간은
시스템의 속도에 의존적이다. 만약 디스크에 로그를 남긴다면, 서버 디스크의 RPM이 높을수록 로그의
처리 속도는 빨라질 것이다.

더 큰 문제는 System.out.println()으로 출력하는 로그가 개발할 때만 사용된다는 것이다.
운영할 때는 전혀 사용되지 않고, 볼 수도 없는 디버그용 로그를 운영 서버에서 고스란히 처리하고 있는 셈이다.

### 로그를 깔금하게 처리해주는 slf4j와 LogBack
기존의 로거들은 출력을 위해서 문자열을 더해 전달해 줘야만 했다. 하지만, slf4j는 format 문자열에
중괄호를 넣고, 그 순서대로 출력하고자 하는 데이터들을 콤마로 구분하여 전달해준다.  
```java
logger.error("message : {}", e.getMessage());
```
이렇게 전달해 주면 로그를 출력하지 않을 경우 필요 없는 문자열 더하기 연산이 발생하지 않는다.

예외처리를 할 때는 아래와 같이 예외 클래스에서 원하는 스택 정보를 가공하여 메세지 처리 하는것도 좋은 방법이다.
```java
if (logger.isErrorEnabled()) {
    StackTraceElement[] ste = exception.getStackTrace();
    StringBuffer str = new StringBuffer();
    int lastIndex = ste.length - 1;
    int count = 1;
    for (int i = lastIndex; i>lastIndex-3; i--) {
    	String className = ste[i].getClassName();
	    String methodName = ste[i].getMethodName();
	    int lineNumber = ste[i].getLineNumber();
    	String fileName = ste[i].getFileName();

	    str.append("\n").append("[" +count++ + "]")
    		.append("className :").append(className).append("\n")
	    	.append("methodName :").append(methodName).append("\n")
		    .append("fileName :").append(fileName).append("\n")
    		.append("lineNumber :").append(lineNumber).append("\n")
	    	.append("message :").append(exception.getMessage()).append("\n")
		    .append("cause :").append(exception.getCause()).append("\n");
    }
    logger.error(str.toString());
}
```

### 추가적으로 정리한 내용
`if (logger.isErrorEnabled()) `와 같은 logging guard는 항상 필요없나?


slf4j, jcl, log4j, logback 관계


참고1 : https://www.slf4j.org/faq.html#logging_performance

참고2 : https://www.youtube.com/watch?v=o2-JaRD9qQE


 
